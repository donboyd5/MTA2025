---
output: html_document
editor_options: 
  chunk_output_type: console
---

{{< include _setup.qmd >}}

# Allocate QCEW data to establishment size groups

```{r}
#| label: get-data
#| output: false

qcshares <- readRDS(fs::path(PDINTERMEDIATE, "qcew_cbpshares.rds"))

# check sum
sum(qcshares$payroll)
readRDS(fs::path(PDINTERMEDIATE, "qmta_atoms.rds")) |> 
  filter(ownerf==1) |> 
  summarise(payroll=sum(payroll))

```

```{r}
#| label: long-file
#| output: false

qclong <- qcshares |> 
  pivot_longer(cols=n0_4:n1000_inf) |> 
  separate_wider_delim(name, delim = "_", names=c("elb", "eub"), cols_remove = FALSE) |> 
  mutate(elb = str_remove(elb, "n") |> as.integer(),
         eub = ifelse(eub=="inf", Inf, as.integer(eub)), # will generate a warning
         estabs_initial = estabs * value)

# verify that all shares add to 1
qclong |> 
  summarise(value=sum(value), .by=c(area, naics)) |> 
  mutate(diff=value - 1) |> 
  arrange(desc(abs(diff))) # good

qclong |> 
  summarise(estabs = first(estabs),
            estabs_initial=sum(estabs_initial), .by=c(area, naics)) |> 
  mutate(diff=estabs_initial - estabs) |> 
  arrange(desc(abs(diff))) # good

```

```{r}
#| label: optimization
#| output: false

source(fs::path(DMAIN, "R", "opt_functions.R"))

a <- proc.time()
qcew_allocated <- qclong |> 
  mutate(pay_emp = payroll / emp) |> 
  # variables that begin with "g" are size-group values
  mutate(allocate(estabs_initial=estabs_initial, emptot=emp[1], estabs_tot=estabs[1]),
         .by=c(year, area, naics)) |> 
  mutate(gemp = gemp_est * gestabs,
         gpayroll = gemp * pay_emp)
b <- proc.time()
b - a # about 5 mins

saveRDS(qcew_allocated, fs::path(PDINTERMEDIATE, "qcew_allocated.rds"))

```

```{r}
#| label: check-results
#| output: true

qcew_allocated <- readRDS(fs::path(PDINTERMEDIATE, "qcew_allocated.rds"))

# summary(qcew_allocated |> select(-res))
# qcew_allocated |> select(-res) |> filter(is.na(gemp))
# 
# glimpse(qcew_allocated)

qcew_allocated |> 
  select(-res) |> 
  summarise(payroll=first(payroll),
            gpayroll=sum(gpayroll, na.rm=TRUE),
            .by=c(area, naics, title)) |> 
  summarise(payroll=sum(payroll), 
            gpayroll=sum(gpayroll)) |> 
  mutate(dpayroll=gpayroll - payroll,
         dpct=dpayroll / payroll) |> 
  gt() |> 
  tab_header("QCEW 2023 reported private sector payroll and sum of 'atomistic' payroll across counties, industries, and employer size groups") |> 
  cols_label(payroll="payroll: reported", gpayroll="payroll: sum of details", dpayroll="sum of details minus reported", dpct="% difference from reported") |> 
  fmt_number(columns = contains("payroll"),
             decimals = 0) |> 
  fmt_percent(columns = dpct,
              decimals=4)

```

```{r}
#| label: cleanup
rm(list = ls())
```

```{r stop_here, echo=FALSE}
knitr::knit_exit()
```

```{r}
#| label: older-test-code
#| eval: false

groups <- qclong |> 
  distinct(area, naics)

groups <- qclong |> 
  summarise(emp=first(emp),
            .by=c(area, naics, title))

use <- groups |> 
  filter(row_number() == 790)
use

data <- qclong |> 
  filter(area==use$area, naics==use$naics)

data <- qclong |> 
  filter(area=="Nassau County", naics=="xxx")

data <- qclong |> 
  filter(area=="Nassau County", naics %in% c("xxx", "322"))

data <- qclong |> 
  right_join(groups |> 
               slice_sample(n=12),
             by = join_by(area, naics))

data <- qclong |> 
  right_join(groups |> 
               arrange(desc(avgemp)) |> 
               slice_head(n=25) |> 
               select(area, naics),
             by = join_by(area, naics))

data <- qclong |> 
  filter(area=="New York County", naics=="622")

data <- qclong |> 
  filter(area=="Richmond", naics=="622")

data <- qclong

# In group 290: `year = 2023`, `area = "Nassau County"`, `naics = "xxx"`
# Caused by error:ℹ In index: 1.Caused by error in `mutate()`:
#ℹ In argument: `allocate(...)`.Caused by error in `initialize()` at pmt_database/R/opt_functions.R:125:3:
# ! all(x0$estabs <= prob$estabs_tot * 3) is not TRUE


```

```{r}
#| label: test


use <- groups |> 
  filter(row_number() == 790)
use

data <- qclong |> 
  # filter(area=="Dutchess County", naics=="111") |> 
  filter(area==use$area, naics==use$naics)
data

check <- data |> 
  mutate(avgwage = totwage / avgemp) |> 
  # inputs: emp = total emp, estabs = total estabs, elb and eub are range bounds, esize_estabs=# estabs in group
  mutate(fempest_weighted(emp=avgemp, estabs=estab, estabs_initial=estabs_initial, emplb=elb, empub=eub, weights = weights), # emp, est, est ss
         .by=c(year, area, naics)) |> 
  mutate(esize_emp = esize_avgemp * esize_estabsadj,
         esize_wage = esize_emp * avgwage)
check
check |> 
  select(emplb=elb,
         empub=eub,
         emptot=avgemp,
         estabs_tot=estab,
         estabs_initial,
         es_emp=esize_avgemp,
         es_estabs=esize_estabsadj,
         es_emptot=esize_emp)


bak <- check

check |> 
  summarise(totwage=first(totwage),
            calcwage=sum(esize_wage),
            .by=c(area, naics, title)) |> 
  summarise(totwage=sum(totwage), 
            calcwage=sum(calcwage)) |> 
  mutate(dwage=calcwage - totwage,
         dpct=dwage / totwage)
  


library(furrr)  # for future_map
library(purrr)  # for map functions

# Set up parallel processing
plan(multisession)  # or multicore if on Unix/Linux

data <- qclong
a <- proc.time()
check <- data |> 
  mutate(avgwage = totwage / avgemp) |>
  group_by(year, area, naics) |>
  nest() |>
  mutate(processed_data = future_map(data, ~ {
    .x |> 
      mutate(allocate(estabs_initial = estabs_initial,
                     emptot = avgemp[1],
                     estabs_tot = estab[1]))
  }, .progress = TRUE)) |>
  select(-data) |>
  unnest(processed_data) |>
  ungroup()
b <- proc.time()
b - a
saveRDS(check, fs::path(PDINTERMEDIATE, "test.rds"))


tmp <- check |> 
  summarise(across(c(estab, avgemp, totwage), first),
            across(c(esize_estabsadj, esize_emp, esize_wage), sum),
            .by=c(area, naics, title)) |> 
  mutate(dest = esize_estabsadj / estab,
         demp = esize_emp - avgemp,
         dwage = esize_wage - totwage,
         estpct=esize_estabsadj / estab - 1,
         emppct = esize_emp / avgemp - 1,
         wagepct = esize_wage / totwage -1)

# Investigate:
#  New York County 622
#  Bronx 622
#  Richmond, Nassau, Suffolk, Rockland 622
#  Queens 523, Richmond 524
#  Bronx 711

check |> 
  filter(area=="New York County", naics=="622")

t2 <- check |> 
  filter(area=="New York County", naics=="622") |> 
  select(area, naics, title, res) |> 
  unnest(res)



# If you want to completely shut down workers
future::plan("sequential")
closeAllConnections()  # closes any remaining connections

check <- data |> 
  mutate(avgwage = totwage / avgemp) |> 
  mutate(allocate(estabs_initial=estabs_initial, emptot=avgemp[1], estabs_tot=estab[1]),
         .by=c(year, area, naics)) |> 
  mutate(esize_emp = esize_avgemp * esize_estabsadj,
         esize_wage = esize_emp * avgwage)
check

check |> 
  summarise(across(c(estab, avgemp, totwage), first),
            across(c(esize_estabsadj, esize_emp, esize_wage), sum),
            .by=c(area, naics, title)) |> 
  mutate(estpct=esize_estabsadj / estab - 1,
         emppct = esize_emp / avgemp - 1,
         wagepct = esize_wage / totwage -1)

check |> 
  select(area, naics, title, elb, initial=estabs_initial, solved=esize_estabsadj) |>
  pivot_longer(c(initial, solved)) |> 
  # ggplot(aes(elb, log(value + 1), colour=name)) +
  ggplot(aes(elb, value, colour=name)) +
  geom_line() +
  facet_wrap(~area + title, scales="free")



check |> 
  select(emplb=elb,
         empub=eub,
         emptot=avgemp,
         estabs_tot=estab,
         estabs_initial,
         es_emp=esize_avgemp,
         es_estabs=esize_estabsadj,
         es_emptot=esize_emp)

# Suffolk County 531 ------------------------------------------------------
estabs_initial <- c(1360.45616973758, 142.281407035176, 50.0619765494137, 17.5656058068118, 
                    2.63484087102178, 0, 0, 0, 0)
estabs_tot <- 1573
emptot <- 5685

allocate(estabs_initial, estabs_tot, emptot)

# ------------ details --------------
prob <- list(
  emplb = c(0, 5, 10, 20, 50, 100, 250, 500, 1000),
  empub = c(4, 9, 19, 49, 99, 249, 499, 999, 2000),
  estabs_initial = estabs_initial,
  emptot = emptot,
  estabs_tot = estabs_tot,
  # penalties: emptot, estabstot, init estabs, bounds, small estabs, emp-without-estabs
  weights = c(50, 100, 20, 5, 10, 5)
)

# Robust initialization ensuring bounds
x0 <- local({
  # local environment -- variables defined here are not visible from the outside
  emp_mid <- (prob$emplb + prob$empub)/2
  target_ratio <- prob$emptot / max(1e-6, sum(emp_mid * prob$estabs_initial))
  
  # Ensure employment bounds
  emp_init <- pmax(prob$emplb, pmin(emp_mid * target_ratio, prob$empub))
  
  # Ensure establishment bounds with smoothing
  estabs_init <- sqrt(pmax(0.1, prob$estabs_initial - 0.5))
  estabs_init <- pmin(estabs_init, prob$estabs_tot * 3)
  estabs_init <- pmax(0.01, estabs_init)  # Strictly positive lower bound
  
  list(emp = emp_init, estabs = estabs_init)
})

# Verify initialization
stopifnot(all(x0$emp >= prob$emplb),
          all(x0$emp <= prob$empub),
          all(x0$estabs >= 0.01),
          all(x0$estabs <= prob$estabs_tot * 3))

# Objective function
objective_function <- function(x, prob) {
  es_emp <- x[1:9]
  es_estabs <- ifelse(x[10:18] < 0.5, 0, 0.5 + x[10:18]^2)
  es_emptot <- es_emp * es_estabs
  
  # Calculate penalty components
  employment_penalty <- ((sum(es_emptot) - prob$emptot)^2) / (prob$emptot^2 + 100)
  estabs_penalty <- ((sum(es_estabs) - prob$estabs_tot)^2) / (prob$estabs_tot^2 + 100)
  initial_match_penalty <- sum((es_estabs - prob$estabs_initial)^2)
  
  bounds_penalty <- sum(sapply(1:9, function(i) {
    if (es_estabs[i] > 0) {
      lower_penalty <- ifelse(es_emp[i] < prob$emplb[i], (prob$emplb[i] - es_emp[i])^2, 0)
      upper_penalty <- ifelse(es_emp[i] > prob$empub[i], (es_emp[i] - prob$empub[i])^2, 0)
      return(lower_penalty + upper_penalty)
    }
    return(0)
  }))
  
  small_estabs_penalty <- sum(ifelse(es_estabs > 0 & es_estabs < 1, (1 - es_estabs)^4, 0))
  emp_without_estabs_penalty <- sum(ifelse(es_estabs == 0 & es_emp > 0, es_emp^2, 0))
  
  # Combine with weights
  sum(c(
    prob$weights[1] * employment_penalty,
    prob$weights[2] * estabs_penalty,
    prob$weights[3] * initial_match_penalty,
    prob$weights[4] * bounds_penalty,
    prob$weights[5] * small_estabs_penalty,
    prob$weights[6] * emp_without_estabs_penalty
  ))
}

# Constraint function
constraint_function <- function(x, prob) {
  es_emp <- x[1:9]
  es_estabs <- ifelse(x[10:18] < 0.5, 0, 0.5 + x[10:18]^2)
  c(sum(es_emp * es_estabs) - prob$emptot,
    sum(es_estabs) - prob$estabs_tot)
}

# Run optimization
res <- nloptr(
  x0 = c(x0$emp, x0$estabs),
  eval_f = objective_function,
  eval_g_eq = constraint_function,
  lb = c(prob$emplb, rep(0.01, 9)),  # Explicit lower bounds
  ub = c(prob$empub, rep(prob$estabs_tot * 3, 9)),
  opts = list(
    algorithm = "NLOPT_LN_COBYLA",
    maxeval = 8000,
    xtol_rel = 1e-7,
    ftol_abs = 1,
    print_level = 0
  ),
  prob = prob
)

# Post-processing with constraint satisfaction
final <- local({
  emp <- pmax(prob$emplb, pmin(res$solution[1:9], prob$empub))
  estabs <- pmax(0, ifelse(res$solution[10:18] < 0.5, 0, 0.5 + res$solution[10:18]^2))
  
  # Scale to exact constraints
  scale_emp <- prob$emptot / sum(emp * estabs)
  scale_estabs <- prob$estabs_tot / sum(estabs)
  
  emp_final <- pmax(prob$emplb, pmin(emp * scale_emp, prob$empub))
  estabs_final <- estabs * scale_estabs
  
  # Respect initial zeros
  estabs_final[prob$estabs_initial == 0 & estabs_final < 0.5] <- 0
  
  # Final scaling to account for zeroing
  scale_emp_final <- prob$emptot / sum(emp_final * estabs_final)
  emp_final <- pmax(prob$emplb, pmin(emp_final * scale_emp_final, prob$empub))
  
  list(emp = emp_final, estabs = estabs_final)
})

# Create results table
results <- data.frame(
  Group = 1:9,
  Estabs_Initial = prob$estabs_initial,
  Estabs_Final = round(final$estabs, 2),
  Emp_per_Estab = round(final$emp, 2),
  Total_Employment = round(final$estabs * final$emp, 2)
)

# Verification
cat("Optimization results:\n")
print(results)
cat("\nVerification:\n")
cat("Total establishments:", sum(results$Estabs_Final), "(Target:", prob$estabs_tot, ")\n")
cat("Total employment:", sum(results$Total_Employment), "(Target:", prob$emptot, ")\n")




```
